{
  "name": "augment",
  "description": "The world's smallest and fastest classical JavaScript inheritance pattern.",
  "version": "3.2.1",
  "keywords": [
    "augment",
    "augments",
    "augmentation",
    "extend",
    "extends",
    "extension",
    "prototype",
    "prototypal",
    "class",
    "classical",
    "object",
    "inheritance",
    "uber",
    "super",
    "constructor",
    "oop"
  ],
  "author": {
    "name": "Aadit M Shah",
    "email": "aaditmshah@myopera.com",
    "url": "http://aaditmshah.github.com/"
  },
  "main": "lib/augment.js",
  "maintainers": [
    {
      "name": "Aadit M Shah",
      "email": "aaditmshah@myopera.com",
      "url": "http://aaditmshah.github.com/"
    }
  ],
  "contributors": [
    {
      "name": "Aadit M Shah",
      "email": "aaditmshah@myopera.com",
      "url": "http://aaditmshah.github.com/"
    },
    {
      "name": "Giovanni Funchal",
      "email": "gafunchal@gmail.com",
      "url": "http://funchal.github.com/"
    }
  ],
  "bugs": {
    "url": "https://github.com/javascript/augment/issues"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://opensource.org/licenses/MIT"
    }
  ],
  "repositories": [
    {
      "type": "git",
      "url": "https://github.com/javascript/augment.git"
    }
  ],
  "dependencies": {},
  "homepage": "http://javascript.github.com/augment",
  "readme": "# augment #\n\nThe world's smallest and fastest classical JavaScript inheritance pattern (`Function.prototype.augment`) is an [eight line function](https://github.com/javascript/augment/blob/master/lib/augment.js#L18 \"augment.js\") which allows you to write [CoffeeScript style classes](http://coffeescript.org/#classes \"CoffeeScript\") with a flair of [simplicity](http://ejohn.org/blog/simple-javascript-inheritance/ \"John Resig -   Simple JavaScript Inheritance\"); and it still [beats the bejesus](http://jsperf.com/oop-benchmark/118 \"JavaScript Object Oriented Libraries Benchmark · jsPerf\") out of other JavaScript inheritance libraries.\n\nInspired by giants like [Jeremy Ashkenas](http://ashkenas.com/ \"Jeremy/Ashkenas — Portfolio\") and [John Resig](http://ejohn.org/ \"John Resig - JavaScript Programmer\"), `augment` is an augmentation of ideas. Classes created using `augment` have a CoffeeScript like structure, and a syntax like John Resig's; but they are more readable, intuitive and orders of magnitude faster. Plus they work on every JavaScript platform.\n\n## Installation and Usage ##\n\nYou can install `augment` on [node.js](http://nodejs.org/ \"node.js\") using the following [npm](https://npmjs.org/ \"npm\") command:\n\n```bash\nnpm install augment\n```\n\nYou can also install `augment` on [RingoJS](http://ringojs.org/ \"Home - RingoJS\") using the following `ringo-admin` command:\n\n```bash\nringo-admin install javascript/augment\n```\n\nSimilarly you can install `augment` for web apps using the following [component](https://github.com/component/component) command:\n\n```bash\ncomponent install javascript/augment\n```\n\nYou can easily include it in [fiddles](http://jsfiddle.net/ \"Create a new Fiddle - jsFiddle\") and [benchmarks](http://jsperf.com/ \"jsPerf: JavaScript performance playground\") using the following HTML code:\n\n```html\n<script src=\"https://raw.github.com/javascript/augment/master/lib/augment.js\"></script>\n```\n\nOtherwise you may simply browse the [source code](https://github.com/javascript/augment/blob/master/lib/augment.js \"javascript/augment\") and stick it into your program.\n\n## Creating your First Class ##\n\nI am a huge follower of keeping things simple and learning by example. So let's begin:\n\n```javascript\nvar Rectangle = Object.augment(function () {\n    this.constructor = function (width, height) {\n        this.height = height;\n        this.width = width;\n    };\n\n    this.area = function () {\n        return this.width * this.height;\n    };\n});\n```\n\nLooks like normal JavaScript right? No mysterious dollar signs or dangling underscores. It's so simple that I don't even need to explain it using comments.\n\nNow let's create our first object:\n\n```javascript\nvar rectangle = new Rectangle(3, 7);\nconsole.log(rectangle.area());\n```\n\nThat's it.\n\n## Creating your Second Class ##\n\nNow let's create another class which augments our first class. It's as simple as:\n\n```javascript\nvar Square = Rectangle.augment(function () {\n    this.constructor = function (side) {\n        Rectangle.call(this, side, side);\n    };\n});\n```\n\nNow let's create an object:\n\n```javascript\nvar square = new Square(5);\nconsole.log(square.area());\n```\n\nSo simple.\n\n## Creating your Third Class ##\n\nWhat about accessing base class `prototype` methods from the derived class? Let's see:\n\n```javascript\nvar Cube = Square.augment(function (base) {\n    this.constructor = function (side) {\n        base.constructor.call(this, side);\n        this.side = side;\n    };\n\n    this.area = function () {\n        return 6 * base.area.call(this);\n    };\n\n    this.volume = function () {\n        return this.side * base.area.call(this);\n    };\n});\n```\n\nAs you can see the second argument passed to the anonymous _class body_ function is the `prototype` of the base class `Square`, which we named `base`. It can be used to access the methods on the `prototype` of the base class.\n\nAlso notice that instead of invoking the super class constructor as `Square.call` we are using `base.constructor.call` instead. Yes there's an additional property lookup but it's essentially the same.\n\nCreating the final object:\n\n```javascript\nvar cube = new Cube(5);\nconsole.log(cube.volume());\nconsole.log(cube.area());\n```\n\n## Redefining the Module Pattern ##\n\nThe [module pattern](http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth \"Adequately Good - JavaScript Module Pattern: In-Depth - by Ben Cherry\") in JavaScript is used to provide privacy and state via an anonymous closure. It may also optionally return an object. You may use `augment` as achieve the same result. As long as you don't define `this.constructor`, `augment` will return a module instead of a class:\n\n```javascript\nvar MODULE = Object.augment(function () {\n    var private = true;\n    this.public = true;\n});\n```\n\nYou may also import values as follows:\n\n```javascript\nvar MODULE = Object.augment(function ($, YAHOO) {\n    // now have access to globals jQuery (as $) and YAHOO in this code\n}, jQuery, YAHOO);\n```\n\nBy default the `prototype` of the function you are augmenting (in this case `Object`) is always imported. It's passed at the end of the argument list.\n\n## Functional Programming Utilities ##\n\nThe `augment` framework was designed keeping code reuse in mind. Hence all the utility functions used to write the actual framework are made available to the user as well. These utilities aid in functional programming in JavaScript. They are documented below:\n\n### Function.bindable ###\n\nThe `bindable` function allows you to create a bindable version of an existing function which when called returns a new function bound to the given arguments. For example:\n\n```javascript\nFunction.prototype.defer = function () {\n    setTimeout.bind(null, this, 0).apply(null, arguments);\n};\n\nvar deferrable = Function.bindable(Function.prototype.defer);\n\nvar deferredAlert = deferrable(alert);\n\ndeferredAlert(\"This will be displayed later.\");\nalert(\"This will be displayed first.\");\n```\n\nAs a thumb rule the name of the bindable version of a function should be an adjective with the suffix _\"able\"_. For example a bindable `bind` would be `bindable` itself (which is what it actually is). A bindable `call` would be `callable`. A bindable `apply` would be `appliable`. You get my drift. Concise and descriptive names are very helpful.\n\n### Function.callable ###\n\nThe `callable` function allows you to create a callable version of an existing function which when called calls the existing function with the given arguments and `this` pointer. For example:\n\n```javascript\nvar defer = Function.callable(Function.prototype.defer);\ndefer(alert, \"This will be displayed later.\");\nalert(\"This will be displayed first.\");\n```\n\nTo make things more clear assume that you pass a function `foo` to `callable` as follows - `Function.callable(foo)`. This is equivalent to `foo.call` (without actually calling `call`). Hence `Function.callable(foo)(that, arg1, ...)` is equivalent to `foo.call(that, arg1, ...)`.\n\n### Array.from ###\n\nThe `Array.from` function allows you to slice an array from a start index to an end index. You can use it to create a one-level deep copy of an array or to convert an array-like object into an array. For example:\n\n```javascript\nvar primes = [2, 3, 5, 7];\nvar oddPrimes = tail(primes); // [3, 5, 7]\n```\n\n### Object.ownPropertyOf ###\n\nThe `ownPropertyOf` function is used to check if an object has own property. It's particularly useful if the object you're testing doesn't have the `Object` constructor in its prototype chain. For example:\n\n```javascript\nvar object = Object.create(null);\nObject.ownPropertyOf(object, \"property\"); // false\n```\n\nThat's all folks!\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "https://github.com/javascript/augment.git"
  },
  "_id": "augment@3.2.1",
  "dist": {
    "shasum": "974e0761b178ee7c2b80e1c024eaab1ba4f9e6f1"
  },
  "_from": "augment@3.2.1",
  "_resolved": "https://registry.npmjs.org/augment/-/augment-3.2.1.tgz"
}
